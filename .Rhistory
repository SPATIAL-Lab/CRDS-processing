calData = rbind(calData, newCol)
}
calData = matrix(nrow = length(uncalData), ncol = 1000)
for(i in 1:length(uncalData)){
calData[i,] = uncalData[i] * cal.slope + cal.int
}
plot(calData[1,])
mea(calData[1,])
mean(calData[1,])
sd(calData[1,])
data.cal <- function(data,element,cal){
## data is the dataframe created using the data.mod function and
## updated with memory-corrected values using the data.mc function
## element is either "O" or "H"
## cal is the list created using the cal.reg function
uncalData<-if(element =="O"){data$d18O_dc}else if(
element=="H"){data$d2H_dc}
##dictates column used
cal.slope <-if(element=="O"){cal$o.slope
}else if(element=="H"){cal$h.slope}
## dictates slope used
cal.int <-if(element=="O"){cal$o.int
}else if(element=="H"){cal$h.int}
## dictates intercept used
calData = matrix(nrow = length(uncalData), ncol = 1000)
for(i in 1:length(uncalData)){
calData[i,] = uncalData[i] * cal.slope + cal.int
}
## calculates calibrated values for the
## specified column. Format is
## memory-corrected value * slope + intercept
return(calData)
}
d18O_cal = data.cal(df, "O", cal)
d18O_cal = data.cal(dc, "O", cal)
d2H_cal = data.cal(dc, "H", cal)
qa <- read.csv(qa.file,stringsAsFactors=FALSE)
slrm <- qa$ID[qa$parameter=="slrm"]
slrm.o <- mean(data$d18O_dc[data$ID==slrm],na.rm=T)
slrm.h <- mean(data$d2H_dc[data$ID==slrm],na.rm=T)
View(dc)
mean(d2H_cal[21:24],)
sd(d2H_cal[21:24],)
mean(apply(d2H_cal[21:24,], 2, mean))
sd(apply(d2H_cal[21:24,], 2, mean))
sqrt(var(d2H_cal[21:24,1]) + var(d2H_cal[21,]))
data.cal <- function(data,element,cal){
## data is the dataframe created using the data.mod function and
## updated with memory-corrected values using the data.mc function
## element is either "O" or "H"
## cal is the list created using the cal.reg function
uncalData<-if(element =="O"){data$d18O_dc}else if(
element=="H"){data$d2H_dc}
##dictates column used
cal.slope <-if(element=="O"){cal$o.slope
}else if(element=="H"){cal$h.slope}
## dictates slope used
cal.int <-if(element=="O"){cal$o.int
}else if(element=="H"){cal$h.int}
## dictates intercept used
calMean = calSD = double()
for(i in 1:length(uncalData)){
calData = uncalData[i] * cal.slope + cal.int
calMean = c(calMean, mean(calData))
calSD = c(calSD, sd(calData))
}
## calculates calibrated values for the
## specified column. Format is
## memory-corrected value * slope + intercept
return(list(calMean = calMean, calSD = calSD))
}
d18O_cal = data.cal(dc, "O", cal)
dc$d18O_csd = d18O_cal$calSD
d2H_cal = data.cal(dc, "H", cal)
dc$d2H_cm = d2H_cal$calMean
dc$d2H_csd = d2H_cal$calSD
data = dc
View(data)
avg <- aggregate(data[,c("d18O_cm","d2H_cm")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
mean, na.rm = T)
dcal = cbind(dc, d18O_cm = d18O_cal$calMean, d18O_csd = d18O_cal$calSD,
d2H_cm = d2H_cal$calMean, d2H_csd = d2H_cal$calSD)
data = dcal
avg <- aggregate(data[,c("d18O_cm","d2H_cm")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
mean, na.rm = T)
View(avg)
sd <- aggregate(data[,c("d18O_cm","d2H_cm")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
sd, na.rm = T)
sd.ave <- aggregate(data[,c("d18O_csd","d2H_csd")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
mean, na.rm = T)
n <- aggregate(data[,c("d18O_cm","d2H_cm")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
count, na.rm = T)
n <- aggregate(data[,c("d18O_cm")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
length, na.rm = T)
n <- aggregate(data[,"d18O_cm"],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
length, na.rm = T)
n <- aggregate(data[,"ID"],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
length, na.rm = T)
n <- aggregate(data[,"ID"],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
nrow, na.rm = T)
n <- aggregate(data[,"ID"],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
nrow)
n <- aggregate(data[,"ID"],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
length)
View(n)
avg <- aggregate(data[,c("d18O_cm","d2H_cm")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
mean, na.rm = T)
sd <- aggregate(data[,c("d18O_cm","d2H_cm")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
sd, na.rm = T)
n <- aggregate(data[,"ID"],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
length)
sd$d18O_cm = sd$d18O_cm / sqrt(n$x)
sd$d2H_cm = sd$d2H_cm / sqrt(n$x)
sd.ave <- aggregate(data[,c("d18O_csd","d2H_csd")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
mean, na.rm = T)
sd$d18O_cm = sqrt(sd$d18O_cm ^ 2 + sd.ave$d18O_csd ^ 2)
sd$d2H_cm = sqrt(sd$d2H_cm ^ 2 + sd.ave$d2H_csd ^ 2)
sd <- aggregate(data[,c("d18O_cm","d2H_cm")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
sd, na.rm = T)
n <- aggregate(data[,"ID"],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
length)
sd$d18O_cm = sd$d18O_cm / sqrt(n$x)
sd$d2H_cm = sd$d2H_cm / sqrt(n$x)
sd.ave <- aggregate(data[,c("d18O_csd","d2H_csd")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
mean, na.rm = T)
sd$d18O_cm = sqrt(sd$d18O_cm ^ 2 + sd.ave$d18O_csd ^ 2)
sd$d2H_cm = sqrt(sd$d2H_cm ^ 2 + sd.ave$d2H_csd ^ 2)
names(ave)[4:5] = c("d18O_avg", "d2H_avg")
names(sd)[4:5] = c("d18O_sd", "d2H_sd")
names(avg)[4:5] = c("d18O_avg", "d2H_avg")
avg <- aggregate(data[,c("d18O_cm","d2H_cm")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
mean, na.rm = T)
std <- aggregate(data[,c("d18O_cm","d2H_cm")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
sd, na.rm = T)
n <- aggregate(data[,"ID"],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
length)
std$d18O_cm = std$d18O_cm / sqrt(n$x)
std$d2H_cm = std$d2H_cm / sqrt(n$x)
std.ave <- aggregate(data[,c("d18O_csd","d2H_csd")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
mean, na.rm = T)
std$d18O_cm = sqrt(std$d18O_cm ^ 2 + std.ave$d18O_csd ^ 2)
std$d2H_cm = sqrt(std$d2H_cm ^ 2 + std.ave$d2H_csd ^ 2)
names(avg)[4:5] = c("d18O_avg", "d2H_avg")
names(std)[4:5] = c("d18O_sd", "d2H_sd")
merge(ave, std, by=c("Port","ID","ID2"))
merge(ave, sd, by=c("Port","ID","ID2"))
avg <- aggregate(data[,c("d18O_cm","d2H_cm")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
mean, na.rm = T)
stdev <- aggregate(data[,c("d18O_cm","d2H_cm")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
sd, na.rm = T)
n <- aggregate(data[,"ID"],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
length)
stdev$d18O_cm = stdev$d18O_cm / sqrt(n$x)
stdev$d2H_cm = stdev$d2H_cm / sqrt(n$x)
stdev.ave <- aggregate(data[,c("d18O_csd","d2H_csd")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
mean, na.rm = T)
stdev$d18O_cm = sqrt(stdev$d18O_cm ^ 2 + stdev.ave$d18O_csd ^ 2)
stdev$d2H_cm = sqrt(stdev$d2H_cm ^ 2 + stdev.ave$d2H_csd ^ 2)
names(avg)[4:5] = c("d18O_avg", "d2H_avg")
names(std)[4:5] = c("d18O_sd", "d2H_sd")
merge(avg, stdev, by=c("Port","ID","ID2"))
names(stdev)[4:5] = c("d18O_sd", "d2H_sd")
merge(avg, stdev, by=c("Port","ID","ID2"))
combine = function(data){
avg <- aggregate(data[,c("d18O_cm","d2H_cm")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
mean, na.rm = T)
stdev <- aggregate(data[,c("d18O_cm","d2H_cm")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
sd, na.rm = T)
n <- aggregate(data[,"ID"],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
length)
stdev$d18O_cm = stdev$d18O_cm / sqrt(n$x)
stdev$d2H_cm = stdev$d2H_cm / sqrt(n$x)
stdev.ave <- aggregate(data[,c("d18O_csd","d2H_csd")],
by=list(Port = data$Port,
ID=data$ID, ID2 = data$ID2),
mean, na.rm = T)
stdev$d18O_cm = sqrt(stdev$d18O_cm ^ 2 + stdev.ave$d18O_csd ^ 2)
stdev$d2H_cm = sqrt(stdev$d2H_cm ^ 2 + stdev.ave$d2H_csd ^ 2)
names(avg)[4:5] = c("d18O_avg", "d2H_avg")
names(stdev)[4:5] = c("d18O_sd", "d2H_sd")
return(merge(avg, stdev, by=c("Port","ID","ID2")))
}
da = combine(dcal)
data = dcal
qa <- read.csv(qa.file,stringsAsFactors=FALSE)
slrm <- qa$ID[qa$parameter=="slrm"]
slrm.o <- mean(data$d18O_dc[data$ID==slrm],na.rm=T)
slrm.h <- mean(data$d2H_dc[data$ID==slrm],na.rm=T)
slrm.o.sd <- sd(data$d18O_dc[data$ID==slrm],na.rm=T)
slrm.h.sd <- sd(data$d2H_dc[data$ID==slrm],na.rm=T)
slrm.o.max <- qa$max[qa$parameter=="slrm_O_range"]
slrm.o.min <- qa$min[qa$parameter=="slrm_O_range"]
slrm.h.max <- qa$max[qa$parameter=="slrm_H_range"]
slrm.h.min <- qa$min[qa$parameter=="slrm_H_range"]
slrm.o.sd.max <- qa$max[qa$parameter=="slrm_O_sd"]
slrm.h.sd.max <- qa$max[qa$parameter=="slrm_H_sd"]
sample.o.sd.max <- qa$max[qa$parameter=="sample_O_sd"]
sample.h.sd.max <- qa$max[qa$parameter=="sample_H_sd"]
data$ignore_run <- ifelse(slrm.o > slrm.o.max | slrm.o < slrm.o.min |
slrm.h > slrm.h.max | slrm.h < slrm.h.min |
slrm.o.sd > slrm.o.sd.max |
slrm.h.sd > slrm.h.sd.max, 1, 0)
data = da
slrm.o <- mean(data$d18O_dc[data$ID==slrm],na.rm=T)
slrm.o.sd <- sd(data$d18O_avg[data$ID==slrm],na.rm=T)
slrm.h.sd <- sd(data$d2H_avg[data$ID==slrm],na.rm=T)
slrm.o.max <- qa$max[qa$parameter=="slrm_O_range"]
slrm.o.min <- qa$min[qa$parameter=="slrm_O_range"]
slrm.h.max <- qa$max[qa$parameter=="slrm_H_range"]
slrm.h.min <- qa$min[qa$parameter=="slrm_H_range"]
slrm.o.sd.max <- qa$max[qa$parameter=="slrm_O_sd"]
slrm.h.sd.max <- qa$max[qa$parameter=="slrm_H_sd"]
sample.o.sd.max <- qa$max[qa$parameter=="sample_O_sd"]
sample.h.sd.max <- qa$max[qa$parameter=="sample_H_sd"]
data$ignore_run <- ifelse(slrm.o > slrm.o.max | slrm.o < slrm.o.min |
slrm.h > slrm.h.max | slrm.h < slrm.h.min |
slrm.o.sd > slrm.o.sd.max |
slrm.h.sd > slrm.h.sd.max, 1, 0)
slrm.o
slrm.o <- mean(data$d18O_avg[data$ID==slrm],na.rm=T)
slrm.h <- mean(data$d2H_avg[data$ID==slrm],na.rm=T)
slrm.o
data$ignore_run <- ifelse(slrm.o > slrm.o.max | slrm.o < slrm.o.min |
slrm.h > slrm.h.max | slrm.h < slrm.h.min |
slrm.o.sd > slrm.o.sd.max |
slrm.h.sd > slrm.h.sd.max, 1, 0)
data$ignore_sample <- ifelse(data$ignore_run == 1 |
complete.cases(data) == FALSE |
data$d18O_sd > sample.o.sd.max |
data$d2H_sd > sample.h.sd.max, 1, 0)
sample.o.sd.max
sample.h.sd.max
View(data)
qa.flag <- function(data, qa.file){
## data is the dataframe created by the data.dc function
## qa.file is the filename of a csv as described in the cal.reg
## function
qa <- read.csv(qa.file,stringsAsFactors=FALSE)
## reads in qa.file
slrm <- qa$ID[qa$parameter=="slrm"]
## creates a character string with the sampleID for slrm
slrm.o <- mean(data$d18O_avg[data$ID==slrm],na.rm=T)
## calculates mean for slrm d18O
slrm.h <- mean(data$d2H_avg[data$ID==slrm],na.rm=T)
## calculates mean for slrm d2H
slrm.o.sd <- sd(data$d18O_avg[data$ID==slrm],na.rm=T)
## calculates sd for slrm d18O
slrm.h.sd <- sd(data$d2H_avg[data$ID==slrm],na.rm=T)
## calculates sd for slrm d2H
slrm.o.max <- qa$max[qa$parameter=="slrm_O_range"]
## stores the value for slrm d18O max acceptable value
slrm.o.min <- qa$min[qa$parameter=="slrm_O_range"]
## stores the value for slrm d18O min acceptable value
slrm.h.max <- qa$max[qa$parameter=="slrm_H_range"]
## stores the value for slrm d2H max acceptable value
slrm.h.min <- qa$min[qa$parameter=="slrm_H_range"]
## stores the value for slrm d2H min acceptable value
slrm.o.sd.max <- qa$max[qa$parameter=="slrm_O_sd"]
## stores the value for slrm d18O max acceptable sd
slrm.h.sd.max <- qa$max[qa$parameter=="slrm_H_sd"]
## stores the value for slrm d2H max acceptable sd
sample.o.sd.max <- qa$max[qa$parameter=="sample_O_sd"]
## stores the value for sample d18O max acceptable sd
sample.h.sd.max <- qa$max[qa$parameter=="sample_H_sd"]
## stores the value for sample d2H max acceptable sd
data$ignore_run <- ifelse(slrm.o > slrm.o.max | slrm.o < slrm.o.min |
slrm.h > slrm.h.max | slrm.h < slrm.h.min |
slrm.o.sd > slrm.o.sd.max |
slrm.h.sd > slrm.h.sd.max, 1, 0)
## returns a 1 if any of the slrm quality parameters are violated
## and a 0 if not
data$ignore_sample <- ifelse(data$ignore_run == 1 |
complete.cases(data) == FALSE |
data$d18O_sd > sample.o.sd.max |
data$d2H_sd > sample.h.sd.max, 1, 0)
## returns a 1 if any of the slrm quality parameters were violated
## as determined by the previous ifelse statement and or if the
## sample sd for d18O or d2H exceeds the maximum acceptable values
if(slrm.o > slrm.o.max | slrm.o < slrm.o.min){warning("slrm d18O average out of range")}
if(slrm.h > slrm.h.max | slrm.h < slrm.h.min){warning("slrm d2H average out of range")}
if(slrm.o.sd > slrm.o.sd.max){warning("slrm d18O sd out of range")}
if(slrm.h.sd > slrm.h.sd.max){warning("slrm d2H sd out of range")}
##generates warnings if parameters are violated
if(any(data$ignore_sample == 1)){warning("sample values ignored")}
##generates warnings if sample values are to be ignored)
return(data)
}
flagged <- qa.flag(da,qa.file)
qa.report <- qa.summary(files$data.file,qa.file,mem,drift,
cal,flagged)
files$data.file
mem
drift
cal
mean(cal)
lapply(cal, mean)
unlist(lapply(cal, mean))
qa.report <- qa.summary(files$data.file,qa.file,mem,drift,
unlist(labbply(cal, mean),flagged)
## qa.summary function summarizes the qa metrics for the run
last4.ref <- df[df$ID %in% refs & df$inj>=7 & df$Port>1,]
## subsets df to include only data for plrm1, plrm2, slrm and
## exclude port 1 & injections lower than 7 (which excludes
## any ports with less than 7 injections)
last4.avg <- aggregate(last4.ref[,c("d18O_cal","d2H_cal")],
by=list(Port=last4.ref$Port,
ID=last4.ref$ID),mean)
## calculates the means for the last 4 injections of each reference
names(last4.avg) <- c("Port","ID","d18O_last4","d2H_last4")
## renames columns
last4.sd <- aggregate(last4.ref[,c("d18O_cal","d2H_cal")],
by=list(Port=last4.ref$Port,
ID=last4.ref$ID),sd)
## calculates the sd for the last 4 injections of each reference
names(last4.sd) <- c("Port","ID","d18O_last4_sd","d2H_last4_sd")
## renames columns
last4.avg <- merge(last4.avg,last4.sd,by=c("Port","ID"))
## merges mean & sd tables
first4.ref <- df[df$ID %in% c(plrm1,plrm2,slrm) & df$inj<=4 &
df$Port>1 & df$Port<=4,]
## subsets df to include only data for plrm1, plrm2, slrm and
## only for ports 2-4 & injections higher than 4
first4.avg <- aggregate(first4.ref[,c("d18O_cal","d2H_cal")],
by=list(Port=first4.ref$Port,
ID=first4.ref$ID),mean)
## calculates the means for the 1st 4 injections of each reference
names(first4.avg) <- c("Port","ID","d18O_1st4","d2H_1st4")
## renames columns
diff <- merge(first4.avg,last4.avg,by=c("Port","ID"))
## merges first 4 & last 4 data
diff$d18O_diff <- diff$d18O_1st4 - diff$d18O_last4
## calculates difference in 1st 4 & last 4 means for d18O
diff$d2H_diff <- diff$d2H_1st4 - diff$d2H_last4
## calculates difference in 1st 4 & last 4 means for d2H
qa.df2 <- qa.df[10:12,c(2,5,6)]
## subsets qa.df to include only rows 10-12 & columns 2, 5 & 6
diff <- merge(diff, qa.df2)
## merges diff & qa.df2
samples.summary <- flagged[flagged$ID != slrm,]
## subsets flagged df to include only non-reference data
slrm.summary <- flagged[flagged$ID == slrm,]
## subsets flagged df to inlcude only data for slrm
ref.all <- df[df$ID %in% c(plrm1,plrm2,slrm),]
## subsets df to include only data for references
data.all <- df[df$ID %in% c(plrm1,plrm2,slrm)==FALSE,]
## subsets df to include only non-reference data
return(list(samples.summary = samples.summary,
slrm.summary = slrm.summary,
ref.all = ref.all,
data.all = data.all,
qa.report = qa.report,
ref.compare = diff))
}
#####################################################################
##                      print.format function                      ##
##              This function formats the dataframes               ##
##              created in process.crds for printing               ##
##              to the console                                     ##
#####################################################################
print_format <- function(data){
## data is a list of dataframes such as that created by the
## process.crds function that includes qa.report & samples.summary
qa.print <- data$qa.report
## stores the dataframe qa.report
qa.print$value[3:20] <- round(as.numeric(qa.print$value[3:20]),3)
## rounds all of the numeric values in qa.print to 3 decimals
samples.s <- data$samples.summary
## stores the dataframe samples.summary
samples.s <- samples.s[,c("Port","ID","ID2","d18O_dc", "d2H_dc",
"d18O_sd","d2H_sd","ignore_run",
"ignore_sample")]
## subsets the dataframe to include only certain columns
names(samples.s)[4:5] <- c("d18O","d2H")
## renames columns 4 & 5
samples.s[,4:7] <- round(samples.s[,4:7],2)
## rounds columns 4-7 to 2 decimal places
return(list(qa = qa.print, samples.summary = samples.s))
}
#####################################################################
##                      plot.gmwl function                         ##
##          This function plots the data against the GMWL          ##
#####################################################################
plot_gmwl <- function(data){
## data is a dataframe such as the samples.summary table created
## by the print.format function
o <- c(min(data$d18O,na.rm=T),max(data$d18O,na.rm=T))
## creates a vector with the minimum and maximum d18O values
h <- o*8+10
## creates a vector with result of multiplying the minimum and
## maximum d18O values by 8 and adding 10
reg <- lm(h~o)
## calculates regression for o & h
h.min <- if(h[1] < min(data$d2H,na.rm=T)){h[1]
} else {min(data$d2H,na.rm=T)}
## compares the minimum calculated value to the minimum measured
## value and returns the lowest of the 2 to be used to set the
## plotting boundaries
h.max <- if(h[2] > max(data$d2H,na.rm=T)){h[2]
} else {max(data$d2H,na.rm=T)}
## compares the maximum calculated value to the maximum measured
## value and returns the greatest of the 2 to be used to set the
## plotting boundaries
plot(data$d18O,data$d2H,main="d18O v. d2H with GMWL",xlim = o,
ylim = c(h.min,h.max), xlab="d18O",ylab="d2H")
abline(reg)
}
#####################################################################
##                      review.data function                       ##
##            This function runs the print.format &                ##
##            plot.gmwl functions & prints the relevant            ##
##            dataframes & plot to the console for review          ##
#####################################################################
review_data <- function(data){
## data is a list of dataframes such as that created by the
## process.crds function that includes qa.report & samples.summary
print.me <- print_format(data)
## runs print.format function
plot_gmwl(print.me$samples.summary)
## runs plot.gmwl function
print(list(qa = print.me$qa,
data = print.me$samples.summary))
}
#####################################################################
##                         db function                             ##
##              This function writes the data to the               ##
##              Water_DB Access database if it does not            ##
##              already exist in the database                      ##
#####################################################################
db <- function(data, analyst){
## data is a list of dataframes such as that created by the
## process.crds function that includes qa.report & samples.summary
library(RODBC)
## loads RODBC library
qa <- data$qa.report
## stores the qa.report table
Instrument <- qa$value[1]
## stores the instrument name
Run_date <- qa$value[2]
Run_date = as.Date(Run_date, format = "%m/%d/%y")
## stores the run date
channel = odbcConnect("WIDB")
## creates a connection to the database, must be loaded as ODBC source w/ this name
existing <- sqlQuery(channel, paste0("SELECT * FROM Parameters_table
WHERE Instrument = '",Instrument, "' AND
Run_date = '",Run_date,"'"))
qa.report <- qa.summary(files$data.file,qa.file,mem,drift,
unlist(lapply(cal, mean),flagged))
qa.report
qa.report <- qa.summary(files$data.file,qa.file,mem,drift,
unlist(lapply(cal, mean),flagged))
flagged <- qa.flag(da,qa.file)
qa.report <- qa.summary(files$data.file,qa.file,mem,drift,
unlist(lapply(cal, mean)),flagged)
900/60
