#################################################################################

######## This function takes a file generated by a Picarro L2130-i for liquid H2O,
######## a second file with the metadata for the run, a third file that defines 
######## parameters associated with the standards used, and finally the names 
######## of three different standards (standard 1 & 2 are used to generate 
######## memory corrections and calibrate values; standard 3 is used to generate 
######## trend corrections and determine the quality of data from a run), and 
######## generates summary data for the non-standard samples and quality data
######## for the run (7 total tables). If the argument csv is set to TRUE, 
######## each of the 7 tables will be printed to your working directory.

######## Assumptions:
######## 1. Formatting of file generated by Picarro is the same as in Sept 2014
######## 2. Metadata file  has 4 columns: tray, port (numeric, i.e. 1,2,etc.), 
######## sample ID, and sample campaign. Column names may vary but the order may not.
######## Additional columns are not allowed and the number of samples should match
######## the number of samples in the isotope file.
######## 3. 1st 4 samples are used to generate memory corrections and must include 
######## greater than or equal to 4 injections
######## 4. Memory corrections and final data reports are for 4 injections per sample.
######## More injections are allowed, but will not be included in the final data reports.
######## 5. 1st 3 samples are excluded from sequence used to create drift correction
######## 6. The parameters file contains a table with the same format as the dataframe
######## created in the 'parameters' object below. These lines can be run to generate
######## a blank table and then populated with the parameters specific to your standards 
######## and saved as a csv in a file location of your choosing:
######## parameters <- data.frame(parameter=c("standard3_O_ave", "standard3_H_ave",  
########           "standard3_O_sd", "standard3_H_sd", "sample_H_sd", "sample_O_sd",  
########            "standard1", "standard2"),min=numeric(8),max=numeric(8),
########            d18O_known=numeric(8), d2H_known=numeric(8))
            


correct <- function(isotope_file, metadata_file, 
 	parameters_file, standard1, standard2, standard3, csv=FALSE){
    
	####READ IN DATA
	metadata <- read.csv(metadata_file,stringsAsFactors=FALSE,col.names=c(
		"Tray", "Port", "ID", "ID2"),strip.white=TRUE)
	isotope_data <- read.csv(isotope_file,stringsAsFactors=FALSE,
		strip.white=TRUE)
	parameters <- read.csv(parameters_file,stringsAsFactors=FALSE)
  
 	####MODIFY DATAFRAMES
	isotope_data <- isotope_data[,1:10] ##subsets by 1st 10 columns
	isotope_data$Port<-as.numeric(regmatches(isotope_data$Port,regexpr(
		"[0-9][0-9]", isotope_data$Port))) ##converts Port data to numeric
	data <- merge(isotope_data,metadata,stringsAsFactors=FALSE) ##merges  
		##isotope data & metadata
	data <- data[with(data,order(Port,Inj.Nr)),] ##orders df by port & inj #

	####GENERATE MEMORY CORRECTION TERMS

	mem_fun <- function(col,inj){
    	a <- head(split(col,data$Port),4) ##splits the given column by Port and 
      ##returns the values for the 1st 4 ports 
    	b <- sapply(a,length) ##lists the length of each vector in a
    	d <- mean(c((mean(a$'2'[(b[2]-1):b[2]])-a$'2'[inj])/(a$'2'[inj]-a$'1'[b[1]]),
      (mean(a$'3'[(b[3]-1):b[3]])-a$'3'[inj])/(a$'3'[inj]-a$'2'[b[2]]),
      (mean(a$'4'[(b[4]-1):b[4]])-a$'4'[inj])/(a$'4'[inj]-a$'3'[b[3]])
    	)) 
      return(d)
	}##will generate memory correction term for given column &
	##inj. Format of each line is 
	##(mean last 2 inj - nth inj)/(nth inj - last inj previous sample)
			
	mem.O <- sapply(1:4,mem_fun,col=data$d.18_16.Mean) ##generates
  	##memory correction terms for d18O for injections 1-4
	mem.H <- sapply(1:4,mem_fun,col=data$d.D_H.Mean) ##generates 
  	##memory correction terms for d2H for injections 1-4
	
 	####GENERATE MEMORY-CORRECTED VALUES FOR STANDARDS 1 & 2
	mc <- function(element,x){
    	col<-if(element =="O"){data$d.18_16.Mean}else if(
      element=="H"){data$d.D_H.Mean} ##dictates column used
    	mem<-if(element=="O"){mem.O}else if(element=="H"){mem.H} 
    	##dictates memory corrections used
    	port <- if(x==standard1 | x==standard2){unique(data$Port
		[data$ID==x])} else {x} ##dictates port used
    	c <- head(col[data$Port==port],4) ##subsets given column by port
    	##and returns 1st 4 values
	d <- tail(col[data$Port==port-1],1) ##subsets given column by
    	##port and returns last value
   	c + (c-d)*mem ##calculates the 4 memory-corrected values for the   
    	##given standard or port number
	}	
  
	corrected.s <- data.frame(
	  ID = c(rep(standard1,4),rep(standard2,4)), ##assigns standard names
	  Injection = rep(1:4,2), ##assigns injection number
	  d18O_mc = c(mc("O",standard1),mc("O",standard2)),
	  ##memory-corrected d18O values for standards 1 & 2
	  d2H_mc = c(mc("H",standard1),mc("H",standard2))
	  ##memory-corrected d2H values for standards 1 & 2
	)
  
	summary.s <- data.frame(
	  	ID = c(standard1,standard2), ##assigns standard names
	  	d18O_ave = c(mean(mc("O",standard1)),mean(mc("O",
		standard2))), ##means of memory-corrected d18O values
	  	d2H_ave = c(mean(mc("H",standard1)),mean(mc("H",
      	standard2))), ##means of memory-corrected d2H values
	  	d18O_last3 = c(mean(tail(data$d.18_16.Mean[data$ID==standard1],n=3)),
	    	mean(tail(data$d.18_16.Mean[data$ID==standard2], n=3))),
	  	##mean of last 3 d18O values for standards 1 & 2
	  	d2H_last3 = c(mean(tail(data$d.D_H.Mean[data$ID==standard1],n=3)),
	    	mean(tail(data$d.D_H.Mean[data$ID==standard2], n=3))),
	 	##mean of last 3 d2H values for standards 1 & 2  	
	  	d18O_known = parameters$d18O_known[parameters$parameter=="standard1" | 
	    	parameters$parameter=="standard2"], ##assigns known d18O values for 
	  	#standards 1 & 2
	  	d2H_known = parameters$d2H_known[parameters$parameter=="standard1" | 
	     	parameters$parameter=="standard2"] ##assigns known d2H values for 
	  	##standards 1 & 2
	)	
  
	####LINEAR REGRESSIONS FOR CALIBRATION
	o.cal <- lm(parameters$d18O_known[parameters$parameter=="standard1" | 
    		parameters$parameter=="standard2"] ~ summary.s$d18O_ave) 
		##regression for d18O
	h.cal <- lm(parameters$d2H_known[parameters$parameter=="standard1" | 
	  	parameters$parameter=="standard2"] ~ summary.s$d2H_ave) 
  		##regression for d2H

  
	####GENERATE MEMORY-CORRECTED, CALIBRATED VALUES FOR STANDARD 3 & SAMPLES
	data.s <- data[data$Port!=1 & data$ID!=standard1 & data$ID!=standard2 &
		data$Inj.Nr<=4,] ##subsets data df to exclude port 1, 
  		##any samples of standard 1 or 2, and include only the 1st 4 injections
 	ports <- unique(data.s$Port) ##generates list of ports for subsetted df
  	data.s$d18O_mc <- unlist(lapply(ports,mc,element="O")) ##generates 
  		##memory-corrected d18O values
  	data.s$d2H_mc <- unlist(lapply(ports,mc,element="H")) ##generates  
  		##memory-corrected d2H values
	data.s$d18O_calib <- data.s$d18O_mc*o.cal$coefficients[[2]]+
		o.cal$coefficients[[1]] ##generates calibrated d18O values by multiplying
		##memory-corrected value by slope & adding intercept from o.ca	
	data.s$d2H_calib <- data.s$d2H_mc*h.cal$coefficients[[2]]+
		h.cal$coefficients[[1]] ##generates calibrated d2H values by multiplying
		##memory-corrected value by slope & adding intercept from h.cal  
	corrected <- data.frame(Injection = data.s$Inj.Nr, ID = data.s$ID, 
		ID2 = data.s$ID2, d18O_mc = data.s$d18O_mc, 
		d2H_mc = data.s$d2H_mc,	d18O_calib = data.s$d18O_calib,	
	  	d2H_calib = data.s$d2H_calib) ##subset of data.s for final reports
  	corrected.3 <- corrected[corrected$ID==standard3,] ##subsets correct for standard3
  	corrected.dat <- corrected[corrected$ID!=standard3,] ##subsets correct for
		##non-standard samples
  
  	####GENERATE AVERAGED VALUES FOR STANDARD 3 & SAMPLES
  	avg <- aggregate(x=data.s[,16:17],by=list(Port=data.s$Port),FUN="mean")
		##generates means for each standard 3 vial & sample for d18O & d2H
	std <- aggregate(x=data.s[,16:17],by=list(Port=data.s$Port),FUN="sd")
		##generates sd for each standard 3 vial & sample for d18O & d2H
	names(avg) <- sub("_calib", "_ave", names(avg)) ##renames columns
	names(std) <- sub("_calib","_sd",names(std)) ##renames columns
	avg <- merge(avg,std) ##merges the avg & sd dfs
	avg$seq <- avg$Port - 4 ##creates a list of run sequence using port 4 as the 
  	##0th sequence
	ids <- unique(data.frame(ID=data$ID,ID2=data$ID2,
		Port=data$Port))##creates a df with ID, ID2 & port
	avg <- merge(avg,ids) ##merges avg & ids dfs
	
	####CREATE DRIFT-CORRECTED VALUES FOR STANDARD 3 & SAMPLES
	o.drift <- lm(avg$d18O_ave[avg$ID==standard3] ~ 
		avg$seq[avg$ID==standard3]) ##regression of mean d18O value 
		##against sequence of sample
	h.drift <- lm(avg$d2H_ave[avg$ID==standard3] ~ 
		avg$seq[avg$ID==standard3]) ##regression of mean d2H value 
  		##against sequence of sample
	avg$d18O_tc <- avg$d18O_ave - avg$seq * o.drift$coefficients[[2]]
		##calculates drift-corrected O sample means using slope of o.drift
	avg$d2H_tc <- avg$d2H_ave - avg$seq * h.drift$coefficients[[2]]
		##calculates drift-corrected H sample means using slope of h.drift
	summary.3 <- avg[avg$ID==standard3,] ##subset of mean values for 
		##standard3
  	summary.dat <- avg[avg$ID!=standard3,] ##subset of mean values for 
		##non-standard samples
  
  	####GENERATE SHARED VALUES TO USE IN SUMMARY TABLES
  	Instrument <- ifelse(grepl("HIDS[0-9]*",isotope_file),
                         regmatches(isotope_file,regexpr("HIDS[0-9]*", 
  		isotope_file)),NA)  ##extracts instrument name from file name
  	Run_date <- strftime(data$Time.Code[1],"%m/%d/%y")
 		##extracts date from the first value in the Time.code 
  		##field and returns it in the format mm/dd/yy

  	####GENERATE FINAL SUMMARY TABLES & WARNINGS
	summary.p <- data.frame(
		Instrument = Instrument, Run_date = Run_date,
		Memory1_O	= mem.O[1], Memory2_O 	= mem.O[2],
		Memory3_O 	= mem.O[3],	Memory4_O	= mem.O[4], 
    		##Memory1_O-Memory4_O = d18O memory corrections for inj 1-4
		Drift_O 	= o.drift$coefficients[[2]], ##slope from o.drift
		Slope_O 	= o.cal$coefficients[[2]], ##slope from o.cal
		Intercept_O	= o.cal$coefficients[[1]], ##intercept from o.cal
		Memory1_H	= mem.H[1], Memory2_H	= mem.H[2],  
		Memory3_H	= mem.H[3], Memory4_H	= mem.H[4], 
    		##Memory1_H-Memory4_H = d2H memory corrections for inj 1-4
		Drift_H	= h.drift$coefficients[[2]], ##returns h.drift slope
		Slope_H	= h.cal$coefficients[[2]], ##returns h.cal slope 
		Intercept_H	= h.cal$coefficients[[1]], ##returns h.cal intercept
		std3_O_ave	= mean(avg$d18O_tc[avg$ID==standard3], na.rm = TRUE), ##mean of
		##drift-corrected d18O values for standard 3
		std3_H_ave	= mean(avg$d2H_tc[avg$ID==standard3], na.rm = TRUE), ##mean of
		##drift-corrected d2H values for standard 3
		std3_O_sd	= sd(avg$d18O_tc[avg$ID==standard3], na.rm = TRUE), ##standard
		##deviation of drift-corrected d18O values for standard 3
		std3_H_sd	= sd(avg$d2H_tc[avg$ID==standard3], na.rm = TRUE), ##standard
		##deviation of drift-corrected d2H values for standard 3
		std3_count	= length(avg$Port[avg$ID==standard3]) - 
			length(avg$d18O_tc[avg$ID==standard3 & is.na(avg$d18O_tc)])
		##count of the number of vials of standard 3		
	)
  
  	o.avg3 <- ifelse(summary.p$std3_O_ave < parameters$min[parameters$parameter==
		"standard3_O_ave"],1, ifelse(summary.p$std3_O_ave > parameters$max[
		parameters$parameter=="standard3_O_ave"],1,0))
	h.avg3 <- ifelse(summary.p$std3_H_ave < parameters$min[parameters$parameter==
		"standard3_H_ave"],1, ifelse(summary.p$std3_H_ave > parameters$max[
		parameters$parameter=="standard3_H_ave"],1,0))
	o.std3 <- ifelse(summary.p$std3_O_sd > parameters$max[parameters$parameter==
		"standard3_O_sd"],1,0)
	h.std3 <- ifelse(summary.p$std3_H_sd > parameters$max[parameters$parameter==
		"standard3_H_sd"],1,0) 
  	##for o.avg3, h.avg3, o.std3 & h.std3, assigns 1 if any of  
	##the parameters are violated and 0 if not
  
	summary.p$Ignore <- ifelse(any(c(o.avg3==1,h.avg3==1,
    		o.std3==1,h.std3==1)),1,0) ##assigns a 1 if parameters are 
    		##violated & a 0 if not

	if(o.avg3 == 1){warning("standard3 d18O average out of range")}
	if(h.avg3 == 1){warning("standard3 d2H average out of range")}
	if(o.std3 == 1){warning("standard3 d18O sd out of range")}
	if(h.std3 == 1){warning("standard3 d2H sd out of range")}
  	##generates warnings if parameters are violated
  
	names(summary.p) <- sub("std3", standard3, names(summary.p)) ##renames columns

  	summary.dat <- data.frame(
    		Instrument = Instrument, Run_date = Run_date, Sequence = summary.dat$seq,
		ID = summary.dat$ID, ID2 = summary.dat$ID2, d18O = summary.dat$d18O_tc,
    		d2H = summary.dat$d2H_tc, d18O_sd = summary.dat$d18O_sd,
    		d2H_sd = summary.dat$d2H_sd) ##rearranges & renames columns in summary.dat
  
  	summary.dat$Ignore <- ifelse(summary.dat$d18O_sd > 
  	                               parameters$max[parameters$parameter=="sample_O_sd"]|
                                   summary.dat$d2H_sd > 
  	                               parameters$max[parameters$parameter=="sample_H_sd"]|
                                   any(c(o.avg3,h.avg3,o.std3,h.std3)==1)|
						is.na(summary.dat$d18O_sd)|
						is.na(summary.dat$d2H_sd),1,0)
                      ##populates with a 1 if either standard deviation is out of
                      ##range or if any of the standard 3 parameters are out of range
			    ##or if either sd is NA

  	if(any(summary.dat$Ignore == 1)){warning("sample values ignored")}
	##generates warnings if sample values are to be ignored
  
  summary.3 <- data.frame(Sequence=summary.3$seq, ID = summary.3$ID, 
	                        d18O_ave=summary.3$d18O_ave, d2H_ave = summary.3$d2H_ave,
	                        d18O_tc=summary.3$d18O_tc, d2H_tc  = summary.3$d2H_tc,
	                        d18O_sd=summary.3$d18O_sd,	d2H_sd = summary.3$d2H_sd)
	##rearranges columns in summary.3

  	####RETURN DATAFRAMES
	tables <- list(standards_corrected = corrected.s,
              standards_summary = summary.s,	
              standard3_corrected = corrected.3,	
              standard3_summary = summary.3,	
              data_corrected = corrected.dat,	
              data_summary = summary.dat,	
              parameters_summary = summary.p)
  
	if(csv==TRUE){lapply(names(tables),function(x) write.csv(tables[[x]],
    paste0("output_",x,".csv"),row.names=FALSE))}
  
  return(tables)
    
}

